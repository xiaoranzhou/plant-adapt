<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PLINK2 WASM Interface</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .file-upload-section {
            margin-bottom: 30px;
            padding: 20px;
            border: 2px dashed #ddd;
            border-radius: 8px;
            background-color: #fafafa;
        }
        .file-group {
            margin-bottom: 15px;
        }
        .file-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }
        .file-group input[type="file"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
        }
        .file-status {
            margin-top: 5px;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
        }
        .file-status.success {
            background-color: #d4edda;
            color: #155724;
        }
        .file-status.error {
            background-color: #f8d7da;
            color: #721c24;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            align-items: center;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover:not(:disabled) {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        .command-input {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
        }
        .output-section {
            margin-top: 30px;
        }
        .output-tabs {
            display: flex;
            border-bottom: 1px solid #ddd;
            margin-bottom: 15px;
        }
        .tab {
            padding: 10px 20px;
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-bottom: none;
            cursor: pointer;
            margin-right: 5px;
            border-radius: 5px 5px 0 0;
        }
        .tab.active {
            background: white;
            border-bottom: 1px solid white;
        }
        .output-content {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            min-height: 200px;
            font-family: monospace;
            white-space: pre-wrap;
            overflow-x: auto;
        }
        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 2s linear infinite;
            margin: 0 auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .file-info {
            background: #e7f3ff;
            padding: 10px;
            border-radius: 4px;
            margin-top: 20px;
            border-left: 4px solid #007bff;
        }
        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 4px;
            margin: 10px 0;
            border-left: 4px solid #dc3545;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>PLINK2 WebAssembly Interface</h1>
        
        <div class="file-upload-section">
            <h3>Upload Files</h3>
            <div class="file-group">
                <label for="fileInput">Select Files:</label>
                <input type="file" id="fileInput" multiple>
                <div id="fileStatus" class="file-status"></div>
            </div>
        </div>

        <div class="controls">
            <input type="text" class="command-input" id="commandInput"
                   placeholder="Enter PLINK2 command (e.g.,--bfile plink --glm allow-no-covars)"
                   value="--bfile plink --glm allow-no-covars">
            <label style="display: flex; align-items: center; gap: 5px;">
                <input type="checkbox" id="renameFamCheckbox" checked>
                Rename .fam
            </label>
            <button id="runButton" onclick="runPlink()">Run PLINK2</button>
            <button id="clearButton" onclick="clearOutput()">Clear Output</button>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Processing with PLINK2...</p>
        </div>

        <div class="output-section">
            <div class="output-tabs">
                <div class="tab active" onclick="switchTab('console')">Console Output</div>
                <div class="tab" onclick="switchTab('files')">Output Files</div>
                <div class="tab" onclick="switchTab('gwas')">GWAS Data Clean</div>
                <div class="tab" onclick="switchTab('manhattan')">Manhattan Plot</div>
                <div class="tab" onclick="switchTab('log')">Log</div>
            </div>
            
            <div class="output-content" id="outputContent">
                <div id="consoleOutput">Ready to process PLINK2 files...</div>
                <div id="filesOutput" style="display: none;"></div>
                <div id="gwasOutput" style="display: none;">
                    <div style="margin-bottom: 15px;">
                        <button id="runGwasButton" onclick="runGwasAnalysis()" style="margin-right: 10px;">Run GWAS Data Clean</button>
                        <span id="gwasStatus"></span>
                    </div>
                    <div id="gwasResults"></div>
                </div>
                <div id="manhattanOutput" style="display: none;">
                    <div class="manhattan-controls" style="margin-bottom: 15px; text-align: center;">
                        <button id="plotFromCleanedButton" onclick="plotFromCleanedData()" style="margin-right: 10px; background-color: #4CAF50;">Plot from Cleaned Data</button>
                        <button onclick="toggleSignificanceLinePlot()" style="margin-right: 10px;">Toggle Significance Line</button>
                        <button onclick="exportPlotImage()" style="margin-right: 10px; background-color: #2196F3;">Export PNG</button>
                        <button onclick="clearManhattanPlot()">Clear</button>
                    </div>
                    <div class="progress" id="manhattanProgressSection" style="display: none; text-align: center; margin-bottom: 15px;">
                        <div id="manhattanProgressMessage">Processing data...</div>
                        <div style="width: 100%; height: 20px; background: #f0f0f0; border-radius: 10px; overflow: hidden; margin: 10px 0; position: relative;">
                            <div id="manhattanProgressFill" style="height: 100%; background: linear-gradient(90deg, #4CAF50, #45a049); transition: width 0.3s ease; width: 0%;"></div>
                            <div id="manhattanProgressText" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-weight: bold; color: #333; font-size: 12px;">0%</div>
                        </div>
                    </div>
                    <div id="manhattanStats" style="text-align: center; margin: 10px 0; color: #666;">
                        Ready to plot Manhattan plot from cleaned GWAS data
                    </div>
                    <div id="manhattanPlotDiv" style="width: 100%; height: 600px; border: 1px solid #ddd; border-radius: 4px; display: flex; align-items: center; justify-content: center; background-color: #f8f9fa; color: #666;"></div>
                </div>
                <div id="logOutput" style="display: none;"></div>
            </div>
        </div>

        <div class="file-info">
            <h4>How to use:</h4>
            <p>1. Upload your files (any format)</p>
            <p>2. Enter PLINK2 command parameters (without the 'plink2' prefix)</p>
            <p>3. Click "Run PLINK2" to execute</p>
            <p>4. View results in the output tabs below</p>
            <p><strong>Example commands:</strong></p>
            <ul>
                <li><code>--freq --out frequency_results</code> - Calculate allele frequencies</li>
                <li><code>--hardy --out hwe_results</code> - Hardy-Weinberg equilibrium test</li>
                <li><code>--missing --out missing_results</code> - Missing data report</li>
                <li><code>--pca --out pca_results</code> - Principal component analysis</li>
            </ul>
        </div>
    </div>

    <script>
        let module;
        let currentTab = 'console';
        let uploadedFiles = {};

        // Configure Module before loading plink.js
        var Module = {
            onRuntimeInitialized: function() {
                module = Module;
                console.log('PLINK2 WASM module loaded successfully!');
                console.log('Available exports:', Object.keys(Module));
                
                // Write any previously uploaded files to WASM filesystem
                //writeStoredFilesToWASM();
                
                document.getElementById('consoleOutput').textContent = 'PLINK2 WASM module loaded successfully! Upload files to begin.';
            },
            print: function(text) {
                console.log('PLINK2 stdout:', text);
                appendToOutput('console', text);
            },
            printErr: function(text) {
                console.error('PLINK2 stderr:', text);
                appendToOutput('console', 'ERROR: ' + text);
            },
            noExitRuntime: true,
            locateFile: function(path, scriptDirectory) {
                return scriptDirectory + path;
            }
        };
    </script>
    <script src="plink2.js"></script>
    <script>

        // File upload handler
        document.getElementById('fileInput').addEventListener('change', function(e) {
            handleMultipleFileUpload(e.target.files);
        });

        async function handleMultipleFileUpload(files) {
            if (!files || files.length === 0) return;

            const statusDiv = document.getElementById('fileStatus');
            statusDiv.textContent = `Loading ${files.length} file(s)...`;
            statusDiv.className = 'file-status';

            let successCount = 0;
            let errorCount = 0;
            let statusMessages = [];

            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const uint8Array = new Uint8Array(arrayBuffer);

                    // Check if rename .fam checkbox is checked and file has .fam extension
                    const renameFamCheckbox = document.getElementById('renameFamCheckbox');
                    let finalFileName = file.name;
                    if (renameFamCheckbox.checked && file.name.toLowerCase().endsWith('.fam')) {
                        finalFileName = 'plink.fam';
                    }

                    uploadedFiles[finalFileName] = {
                        name: finalFileName,
                        data: uint8Array,
                        size: uint8Array.length
                    };

                    // Write file to WASM filesystem immediately if module is ready
                    if (module && module.FS) {
                        module.FS.writeFile(finalFileName, uint8Array);
                        console.log(`Written ${finalFileName} to WASM filesystem (${formatFileSize(uint8Array.length)})`);

                        if (finalFileName !== file.name) {
                            statusMessages.push(`✓ <strong>${file.name}</strong> <span style="color: #007bff;">→ ${finalFileName}</span> (${formatFileSize(uint8Array.length)}) <em style="color: #28a745;">[RENAMED]</em>`);
                            appendToOutput('console', `Uploaded & written: ${file.name} renamed to ${finalFileName} (${formatFileSize(uint8Array.length)}) [RENAMED]`);
                        } else {
                            statusMessages.push(`✓ <strong>${file.name}</strong> (${formatFileSize(uint8Array.length)})`);
                            appendToOutput('console', `Uploaded & written: ${file.name} (${formatFileSize(uint8Array.length)})`);
                        }
                        successCount++;
                    } else {
                        if (finalFileName !== file.name) {
                            statusMessages.push(`✓ <strong>${file.name}</strong> <span style="color: #007bff;">→ ${finalFileName}</span> (${formatFileSize(uint8Array.length)}) <em style="color: #28a745;">[RENAMED]</em> - In memory`);
                            appendToOutput('console', `Uploaded: ${file.name} renamed to ${finalFileName} (${formatFileSize(uint8Array.length)}) [RENAMED] - Will write to FS when available`);
                        } else {
                            statusMessages.push(`✓ <strong>${file.name}</strong> (${formatFileSize(uint8Array.length)}) - In memory`);
                            appendToOutput('console', `Uploaded: ${file.name} (${formatFileSize(uint8Array.length)}) - Will write to FS when available`);
                        }
                        successCount++;
                    }
                } catch (error) {
                    statusMessages.push(`✗ ${file.name}: ${error.message}`);
                    appendToOutput('console', `Error uploading ${file.name}: ${error.message}`);
                    errorCount++;
                }
            }

            // Update status display
            if (errorCount === 0) {
                statusDiv.className = 'file-status success';
            } else if (successCount === 0) {
                statusDiv.className = 'file-status error';
            } else {
                statusDiv.className = 'file-status';
            }
            
            statusDiv.innerHTML = statusMessages.join('<br>');
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        function runPlink() {
            if (!module) {
                showError('WASM module not loaded yet. Please wait.');
                return;
            }

            if (Object.keys(uploadedFiles).length === 0) {
                showError('Please upload at least one file.');
                return;
            }

            const command = document.getElementById('commandInput').value.trim();
            if (!command) {
                showError('Please enter a PLINK2 command.');
                return;
            }

            document.getElementById('loading').style.display = 'block';
            document.getElementById('runButton').disabled = true;

            appendToOutput('console', `\n=== Running PLINK2 ===`);
            appendToOutput('console', `Command: ${command}`);
            appendToOutput('console', '');

            setTimeout(() => {
                try {
                    // Prepare arguments
                    const args = [  ...command.split(' ').filter(arg => arg.length > 0)];
                    
                    appendToOutput('console', `Arguments: ${args.join(' ')}`);
                    
                    // Set up arguments for the WASM module
                    module.arguments = args;
                    
                    // Run PLINK2 by calling the main function
                    let result;
                    if (typeof module.callMain === 'function') {
                        result = module.callMain(args);
                    } else if (typeof module._main === 'function') {
                        // Allocate memory for arguments
                        const argvPtr = module._malloc(args.length * 4);
                        for (let i = 0; i < args.length; i++) {
                            const argPtr = module.allocateUTF8(args[i]);
                            module.setValue(argvPtr + i * 4, argPtr, 'i32');
                        }
                        result = module._main(args.length, argvPtr);
                    } else {
                        throw new Error('Cannot find main function in WASM module');
                    }
                    
                    appendToOutput('console', `\nPLINK2 finished with exit code: ${result}`);
                    
                    // List output files
                    listOutputFiles();
                    
                } catch (error) {
                    console.error('PLINK2 execution error:', error);
                    appendToOutput('console', `Error running PLINK2: ${error.message}`);
                    showError(`Error: ${error.message}`);
                } finally {
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('runButton').disabled = false;
                }
            }, 100); // Small delay to ensure UI updates
        }

        function listOutputFiles() {
            try {
                const FS = module.FS || module['FS'];
                if (!FS) {
                    document.getElementById('filesOutput').textContent = 'File system not available in WASM module. Check console for output.';
                    return;
                }

                const files = FS.readdir('/');
                const outputFiles = files.filter(f => 
                    f !== '.' && f !== '..' && 
                    !f.startsWith('input.') && 
                    f !== 'dev' && f !== 'tmp' && f !== 'proc'
                );

                if (outputFiles.length > 0) {
                    let filesContent = 'Output files generated:\n\n';
                    outputFiles.forEach(fileName => {
                        try {
                            const stat = FS.stat(fileName);
                            if (FS.isFile(stat.mode)) {
                                const size = formatFileSize(stat.size);
                                filesContent += `📄 ${fileName} (${size})\n`;
                                
                                // Try to read and preview text files
                                if (fileName.endsWith('.log') || fileName.endsWith('.txt') || 
                                    fileName.includes('freq') || fileName.includes('missing') || 
                                    fileName.includes('hardy') || fileName.includes('pca')) {
                                    try {
                                        const content = FS.readFile(fileName, { encoding: 'utf8' });
                                        const preview = content.length > 1000 ? 
                                            content.substring(0, 1000) + '\n... (truncated)' : content;
                                        filesContent += `\nContent preview:\n${preview}\n\n`;
                                        
                                        // Create download link
                                        const blob = new Blob([content], { type: 'text/plain' });
                                        const url = URL.createObjectURL(blob);
                                        filesContent += `<a href="${url}" download="${fileName}">Download ${fileName}</a>\n\n`;
                                    } catch (e) {
                                        filesContent += '(Binary file - cannot preview)\n\n';
                                    }
                                }
                            }
                        } catch (e) {
                            filesContent += `❌ ${fileName} (error reading file)\n`;
                        }
                    });
                    
                    document.getElementById('filesOutput').innerHTML = filesContent;
                    switchTab('files');
                } else {
                    document.getElementById('filesOutput').textContent = 'No output files generated.';
                }
            } catch (error) {
                document.getElementById('filesOutput').textContent = `Error listing files: ${error.message}\nCheck console output for PLINK2 results.`;
                console.error('Error listing output files:', error);
            }
        }

        function switchTab(tab) {
            // Update tab appearance
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');

            // Show/hide content
            document.getElementById('consoleOutput').style.display = tab === 'console' ? 'block' : 'none';
            document.getElementById('filesOutput').style.display = tab === 'files' ? 'block' : 'none';
            document.getElementById('gwasOutput').style.display = tab === 'gwas' ? 'block' : 'none';
            document.getElementById('manhattanOutput').style.display = tab === 'manhattan' ? 'block' : 'none';
            document.getElementById('logOutput').style.display = tab === 'log' ? 'block' : 'none';

            currentTab = tab;
        }

        function appendToOutput(tab, text) {
            const outputDiv = document.getElementById(tab + 'Output');
            outputDiv.textContent += text + '\n';
            outputDiv.scrollTop = outputDiv.scrollHeight;
        }

        function clearOutput() {
            document.getElementById('consoleOutput').textContent = 'Output cleared.\n';
            document.getElementById('filesOutput').textContent = '';
            document.getElementById('logOutput').textContent = '';
        }

        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.textContent = message;
            
            const container = document.querySelector('.container');
            container.insertBefore(errorDiv, container.firstChild);
            
            setTimeout(() => errorDiv.remove(), 5000);
        }

        // Handle Enter key in command input
        document.getElementById('commandInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                runPlink();
            }
        });

        // GWAS Analysis Functions
        let gwasWorker = null;

        async function runGwasAnalysis() {
            const statusEl = document.getElementById('gwasStatus');
            const resultsEl = document.getElementById('gwasResults');
            const buttonEl = document.getElementById('runGwasButton');

            try {
                // Check if WASM module is loaded
                if (!module) {
                    throw new Error('PLINK2 WASM module not loaded yet. Please wait for module to initialize.');
                }

                buttonEl.disabled = true;
                statusEl.textContent = 'Reading GWAS file from WASM filesystem...';
                resultsEl.innerHTML = 'Initializing...';

                // Read file from WASM filesystem in main thread
                const filename = 'plink2.PHENO1.glm.linear';
                let fileContent;

                try {
                    const stat = module.FS.stat(filename);
                    if (!module.FS.isFile(stat.mode)) {
                        throw new Error(`${filename} is not a file`);
                    }
                    console.log(`Found ${filename} in WASM filesystem (${stat.size} bytes)`);

                    statusEl.textContent = 'Converting file data...';

                    // Read file as Uint8Array
                    const fileData = module.FS.readFile(filename);

                    // Convert to string efficiently in chunks
                    const chunkSize = 65536; // 64KB chunks
                    fileContent = '';

                    for (let i = 0; i < fileData.length; i += chunkSize) {
                        const chunk = fileData.subarray(i, Math.min(i + chunkSize, fileData.length));
                        fileContent += String.fromCharCode.apply(null, chunk);

                        // Update progress for large files
                        if (fileData.length > 1000000) { // > 1MB
                            const progress = Math.round((i / fileData.length) * 100);
                            statusEl.textContent = `Converting file data: ${progress}%`;
                            await new Promise(resolve => setTimeout(resolve, 1)); // Allow UI update
                        }
                    }

                    console.log(`File content converted (${fileContent.length} characters)`);

                } catch (fsError) {
                    throw new Error(`File ${filename} not found in WASM filesystem. Please run PLINK2 analysis first to generate this file.`);
                }

                statusEl.textContent = 'Starting GWAS data processing...';
                resultsEl.innerHTML = 'Processing...';

                // Create or restart worker
                if (gwasWorker) {
                    gwasWorker.terminate();
                }
                gwasWorker = new Worker('clean-data-worker.js');

                // Handle worker messages
                gwasWorker.onmessage = function(e) {
                    const { type, message, data, processed, total, valid } = e.data;

                    switch (type) {
                        case 'status':
                            statusEl.textContent = message;
                            break;

                        case 'progress':
                            statusEl.textContent = `Processing: ${processed.toLocaleString()}/${total.toLocaleString()} lines (${valid.toLocaleString()} valid)`;
                            const percentage = Math.round((processed / total) * 100);
                            resultsEl.innerHTML = `Progress: ${percentage}% - ${valid.toLocaleString()} valid entries found`;
                            break;

                        case 'complete':
                            statusEl.textContent = 'Analysis complete!';
                            // Store data globally for download functionality
                            window.lastGwasData = data;
                            displayGwasResults(data);
                            buttonEl.disabled = false;
                            break;

                        case 'error':
                            statusEl.textContent = 'Error: ' + message;
                            resultsEl.innerHTML = '<div style="color: red;">Error: ' + message + '</div>';
                            buttonEl.disabled = false;
                            break;
                    }
                };

                gwasWorker.onerror = function(error) {
                    statusEl.textContent = 'Worker error occurred';
                    resultsEl.innerHTML = '<div style="color: red;">Worker error: ' + error.message + '</div>';
                    buttonEl.disabled = false;
                };

                // Start the worker with file content
                gwasWorker.postMessage({
                    inputContent: fileContent,
                    outputType: 'full' // or 'test' for smaller dataset
                });

            } catch (error) {
                statusEl.textContent = 'Error: ' + error.message;
                resultsEl.innerHTML = '<div style="color: red;">Error: ' + error.message + '</div>';
                buttonEl.disabled = false;
            }
        }

        function displayGwasResults(gwasData) {
            const resultsEl = document.getElementById('gwasResults');

            if (!gwasData || !gwasData.data || gwasData.data.length === 0) {
                resultsEl.innerHTML = '<div>No valid GWAS data found.</div>';
                return;
            }

            // Create summary
            let html = '<h4>GWAS Data Summary</h4>';
            html += `<p><strong>Total valid entries:</strong> ${gwasData.data.length.toLocaleString()}</p>`;
            if (gwasData.stats) {
                html += `<p><strong>Processed lines:</strong> ${gwasData.stats.totalLines.toLocaleString()}</p>`;
                html += `<p><strong>Valid lines:</strong> ${gwasData.stats.validLines.toLocaleString()}</p>`;
                html += `<p><strong>Filtered out:</strong> ${gwasData.stats.filteredLines.toLocaleString()}</p>`;
            }

            // Show data preview (first 10 rows)
            html += '<h4>Data Preview (first 10 rows)</h4>';
            html += '<table style="border-collapse: collapse; width: 100%;">';
            html += '<tr style="background-color: #f0f0f0;">';
            gwasData.header.forEach(col => {
                html += `<th style="border: 1px solid #ddd; padding: 8px;">${col}</th>`;
            });
            html += '</tr>';

            const previewData = gwasData.data.slice(0, 10);
            previewData.forEach(row => {
                html += '<tr>';
                row.forEach(cell => {
                    html += `<td style="border: 1px solid #ddd; padding: 8px;">${cell}</td>`;
                });
                html += '</tr>';
            });
            html += '</table>';

            // Add download functionality - Create blob without pretty printing to avoid memory issues
            html += '<h4>Download</h4>';
            html += '<p>Click the button below to download the cleaned GWAS data:</p>';
            html += '<button onclick="downloadGwasData()" style="background-color: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">📄 Download Cleaned GWAS Data (JSON)</button>';

            // Statistical summary - Process in chunks to avoid call stack issues
            if (gwasData.data.length > 0) {
                html += '<h4>Statistical Summary</h4>';

                // Process statistics in smaller chunks to avoid call stack overflow
                let minP = Infinity;
                let maxP = -Infinity;
                let significantCount = 0;
                const chromosomeSet = new Set();

                // Process data in chunks of 10,000 to avoid call stack overflow
                const chunkSize = 10000;
                for (let i = 0; i < gwasData.data.length; i += chunkSize) {
                    const chunk = gwasData.data.slice(i, i + chunkSize);

                    for (const row of chunk) {
                        const pVal = row[2];
                        const chrom = row[0];

                        if (pVal < minP) minP = pVal;
                        if (pVal > maxP) maxP = pVal;
                        if (pVal < 5e-8) significantCount++;
                        chromosomeSet.add(chrom);
                    }
                }

                const chromosomes = Array.from(chromosomeSet).sort((a, b) => a - b);

                html += `<p><strong>P-value range:</strong> ${minP.toExponential(3)} - ${maxP.toFixed(4)}</p>`;
                html += `<p><strong>Chromosomes:</strong> ${chromosomes.join(', ')}</p>`;
                html += `<p><strong>Significant variants (p < 5e-8):</strong> ${significantCount.toLocaleString()}</p>`;
            }

            resultsEl.innerHTML = html;
        }

        // Separate function to handle download to avoid memory issues
        function downloadGwasData() {
            try {
                // Get the data from the last analysis
                if (!window.lastGwasData) {
                    alert('No GWAS data available for download');
                    return;
                }

                // Create JSON string without pretty printing
                const jsonData = JSON.stringify(window.lastGwasData);
                const blob = new Blob([jsonData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                // Create temporary download link
                const a = document.createElement('a');
                a.href = url;
                a.download = 'gwas_cleaned_data.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                // Clean up the object URL
                setTimeout(() => URL.revokeObjectURL(url), 1000);

            } catch (error) {
                console.error('Download error:', error);
                alert('Error creating download: ' + error.message);
            }
        }

        // Manhattan Plot Functions
        let manhattanWorker = null;
        let manhattanCurrentData = null;
        let showSignificanceLine = true;
        let manhattanProcessingStartTime = 0;
        const significanceThreshold = -Math.log10(5e-8);

        // Define colors for each chromosome
        const chrColors = [
            '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd',
            '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf',
            '#aec7e8', '#ffbb78', '#98df8a', '#ff9896', '#c5b0d5',
            '#c49c94', '#f7b6d3', '#c7c7c7', '#dbdb8d', '#9edae5',
            '#393b79', '#637939'
        ];

        function createManhattanWorker() {
            const workerScript = `
                let processedData = null;

                self.onmessage = function(e) {
                    const { type, data } = e.data;

                    switch(type) {
                        case 'PROCESS_DATA':
                            processGWASData(data);
                            break;
                        case 'CREATE_TRACES':
                            createPlotTraces(data);
                            break;
                    }
                };

                function processGWASData(data) {
                    self.postMessage({ type: 'STATUS', message: 'Starting Manhattan plot processing...' });

                    const processed = [];
                    let currentOffset = 0;
                    const chromosomes = [...new Set(data.map(d => d[0]))].sort((a, b) => a - b);
                    const totalChromosomes = chromosomes.length;

                    for (let chrIndex = 0; chrIndex < totalChromosomes; chrIndex++) {
                        const chr = chromosomes[chrIndex];

                        self.postMessage({
                            type: 'PROGRESS',
                            progress: (chrIndex / totalChromosomes) * 60,
                            message: \`Processing chromosome \${chr} (\${chrIndex + 1}/\${totalChromosomes})...\`
                        });

                        const chrData = data.filter(d => d[0] === chr)
                            .sort((a, b) => a[1] - b[1]);

                        if (chrData.length === 0) continue;

                        // Find max position efficiently
                        let maxPos = 0;
                        for (let i = 0; i < chrData.length; i++) {
                            if (chrData[i][1] > maxPos) {
                                maxPos = chrData[i][1];
                            }
                        }

                        for (let i = 0; i < chrData.length; i++) {
                            const d = chrData[i];
                            processed.push({
                                chr: d[0],
                                originalPos: d[1],
                                position: currentOffset + d[1],
                                pValue: d[2],
                                logP: -Math.log10(Math.max(d[2], 1e-300))
                            });
                        }

                        currentOffset += maxPos;
                    }

                    processedData = processed;
                    self.postMessage({
                        type: 'DATA_PROCESSED',
                        data: processed,
                        dataCount: processed.length,
                        progress: 60,
                        message: \`Data processing complete. Processed \${processed.length.toLocaleString()} points.\`
                    });
                }

                function createPlotTraces(config) {
                    if (!processedData) {
                        self.postMessage({ type: 'ERROR', message: 'No processed data available' });
                        return;
                    }

                    self.postMessage({ type: 'STATUS', message: 'Creating plot traces...' });

                    const traces = [];
                    const chromosomes = [...new Set(processedData.map(d => d.chr))].sort((a, b) => a - b);
                    const chrColors = config.chrColors;
                    const totalChromosomes = chromosomes.length;

                    for (let index = 0; index < totalChromosomes; index++) {
                        const chr = chromosomes[index];

                        self.postMessage({
                            type: 'PROGRESS',
                            progress: 60 + (index / totalChromosomes) * 30,
                            message: \`Creating trace for chromosome \${chr} (\${index + 1}/\${totalChromosomes})...\`
                        });

                        const chrData = processedData.filter(d => d.chr === chr);
                        if (chrData.length === 0) continue;

                        const trace = {
                            x: chrData.map(d => d.position),
                            y: chrData.map(d => d.logP),
                            mode: 'markers',
                            type: 'scattergl',
                            name: \`Chr \${chr}\`,
                            marker: {
                                color: chrColors[(chr - 1) % chrColors.length],
                                size: 4,
                                opacity: 0.7,
                                line: { width: 0 }
                            },
                            hovertemplate:
                                '<b>Chr %{customdata[0]}</b><br>' +
                                'Position: %{customdata[1]:,}<br>' +
                                'P-value: %{customdata[2]:.2e}<br>' +
                                '-log10(P): %{y:.2f}<br>' +
                                '<extra></extra>',
                            customdata: chrData.map(d => [d.chr, d.originalPos, d.pValue]),
                            showlegend: false
                        };

                        traces.push(trace);
                    }

                    self.postMessage({
                        type: 'PROGRESS',
                        progress: 90,
                        message: 'Adding significance line and calculating ticks...'
                    });

                    // Add significance line if requested
                    if (config.showSignificanceLine && processedData.length > 0) {
                        let maxPos = 0;
                        for (let i = 0; i < processedData.length; i++) {
                            if (processedData[i].position > maxPos) {
                                maxPos = processedData[i].position;
                            }
                        }

                        traces.push({
                            x: [0, maxPos],
                            y: [config.significanceThreshold, config.significanceThreshold],
                            mode: 'lines',
                            type: 'scatter',
                            name: 'Significance (5×10⁻⁸)',
                            line: {
                                color: 'red',
                                width: 2,
                                dash: 'dash'
                            },
                            hoverinfo: 'none',
                            showlegend: false
                        });
                    }

                    // Calculate chromosome ticks
                    const ticks = [];
                    const labels = [];
                    for (let i = 0; i < chromosomes.length; i++) {
                        const chr = chromosomes[i];
                        const chrData = processedData.filter(d => d.chr === chr);
                        if (chrData.length > 0) {
                            let minPos = Infinity;
                            let maxPos = -Infinity;
                            for (let j = 0; j < chrData.length; j++) {
                                const pos = chrData[j].position;
                                if (pos < minPos) minPos = pos;
                                if (pos > maxPos) maxPos = pos;
                            }
                            ticks.push((minPos + maxPos) / 2);
                            labels.push(chr.toString());
                        }
                    }

                    self.postMessage({
                        type: 'TRACES_READY',
                        traces: traces,
                        ticks: ticks,
                        labels: labels,
                        dataCount: processedData.length,
                        progress: 100,
                        message: \`Manhattan plot ready! Displaying \${processedData.length.toLocaleString()} points.\`
                    });
                }

                self.onerror = function(error) {
                    self.postMessage({
                        type: 'ERROR',
                        message: 'Worker error: ' + error.message,
                        error: error
                    });
                };
            `;

            const blob = new Blob([workerScript], { type: 'application/javascript' });
            return new Worker(URL.createObjectURL(blob));
        }

        function plotFromCleanedData() {
            if (!window.lastGwasData || !window.lastGwasData.data || window.lastGwasData.data.length === 0) {
                alert('No cleaned GWAS data available. Please run GWAS Data Clean first.');
                return;
            }

            const plotButton = document.getElementById('plotFromCleanedButton');
            plotButton.disabled = true;

            showManhattanProgress();
            updateManhattanStatus('Initializing Manhattan plot...');

            manhattanProcessingStartTime = performance.now();

            // Create or restart worker
            if (manhattanWorker) {
                manhattanWorker.terminate();
            }

            try {
                manhattanWorker = createManhattanWorker();
            } catch (error) {
                console.error('Failed to create Manhattan worker:', error);
                document.getElementById('manhattanPlotDiv').innerHTML =
                    '<div style="color: red; padding: 20px;">Error: Could not create Web Worker for Manhattan plot.</div>';
                plotButton.disabled = false;
                return;
            }

            // Handle worker messages
            manhattanWorker.onmessage = function(e) {
                const { type, traces, ticks, labels, dataCount, progress, message, error } = e.data;

                switch(type) {
                    case 'STATUS':
                        updateManhattanStatus(message);
                        break;
                    case 'PROGRESS':
                        updateManhattanProgress(progress, message);
                        break;
                    case 'DATA_PROCESSED':
                        manhattanCurrentData = e.data.data;
                        updateManhattanStatus(`Data processed: \${dataCount.toLocaleString()} points`);

                        // Continue to create traces
                        manhattanWorker.postMessage({
                            type: 'CREATE_TRACES',
                            data: {
                                chrColors: chrColors,
                                showSignificanceLine: showSignificanceLine,
                                significanceThreshold: significanceThreshold
                            }
                        });
                        break;
                    case 'TRACES_READY':
                        createManhattanPlot(traces, ticks, labels, dataCount);
                        hideManhattanProgress();
                        updateManhattanStatus('Manhattan plot complete!');
                        plotButton.disabled = false;
                        break;
                    case 'ERROR':
                        updateManhattanStatus('ERROR: ' + message);
                        hideManhattanProgress();
                        document.getElementById('manhattanPlotDiv').innerHTML =
                            '<div style="color: red; padding: 20px;">Error: ' + message + '</div>';
                        plotButton.disabled = false;
                        break;
                }
            };

            manhattanWorker.onerror = function(error) {
                console.error('Manhattan worker error:', error);
                updateManhattanStatus('Worker error: ' + error.message);
                hideManhattanProgress();
                plotButton.disabled = false;
            };

            // Start the worker
            manhattanWorker.postMessage({ type: 'PROCESS_DATA', data: window.lastGwasData.data });
        }

        function createManhattanPlot(traces, ticks, labels, dataCount) {
            const layout = {
                title: {
                    text: 'Manhattan Plot - GWAS Results',
                    font: { size: 20 }
                },
                xaxis: {
                    title: {
                        text: 'Chromosome',
                        font: { size: 16, family: 'Arial, sans-serif' }
                    },
                    showgrid: true,
                    gridcolor: '#f0f0f0',
                    tickmode: 'array',
                    tickvals: ticks,
                    ticktext: labels,
                    fixedrange: false,
                    titlefont: { size: 14 }
                },
                yaxis: {
                    title: {
                        text: '-log₁₀(P-value)',
                        font: { size: 16, family: 'Arial, sans-serif' }
                    },
                    showgrid: true,
                    gridcolor: '#f0f0f0',
                    fixedrange: false,
                    titlefont: { size: 14 }
                },
                hovermode: 'closest',
                showlegend: false,
                plot_bgcolor: 'white',
                paper_bgcolor: 'white',
                margin: { l: 60, r: 30, t: 60, b: 60 }
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d'],
                displaylogo: false,
                toImageButtonOptions: {
                    format: 'png',
                    filename: 'manhattan_plot',
                    height: 600,
                    width: 1200,
                    scale: 2
                }
            };

            Plotly.newPlot('manhattanPlotDiv', traces, layout, config);

            const totalPoints = dataCount || 0;
            document.getElementById('manhattanStats').innerHTML =
                `<span style="color: #28a745;">Successfully plotted \${totalPoints.toLocaleString()} data points across \${labels.length} chromosomes</span>`;
        }

        function showManhattanProgress() {
            document.getElementById('manhattanProgressSection').style.display = 'block';
        }

        function hideManhattanProgress() {
            document.getElementById('manhattanProgressSection').style.display = 'none';
        }

        function updateManhattanProgress(progress, message) {
            document.getElementById('manhattanProgressFill').style.width = progress + '%';
            document.getElementById('manhattanProgressText').textContent = Math.round(progress) + '%';
            if (message) {
                document.getElementById('manhattanProgressMessage').textContent = message;
            }
        }

        function updateManhattanStatus(message) {
            console.log('Manhattan Status:', message);
            document.getElementById('manhattanStats').textContent = message;
        }

        function toggleSignificanceLinePlot() {
            showSignificanceLine = !showSignificanceLine;
            if (manhattanCurrentData && manhattanWorker) {
                showManhattanProgress();
                updateManhattanStatus('Updating significance line...');
                manhattanWorker.postMessage({
                    type: 'CREATE_TRACES',
                    data: {
                        chrColors: chrColors,
                        showSignificanceLine: showSignificanceLine,
                        significanceThreshold: significanceThreshold
                    }
                });
            }
        }

        function exportPlotImage() {
            const plotDiv = document.getElementById('manhattanPlotDiv');
            if (manhattanCurrentData && plotDiv && plotDiv._fullLayout) {
                Plotly.downloadImage('manhattanPlotDiv', {
                    format: 'png',
                    filename: 'manhattan_plot',
                    height: 600,
                    width: 1200,
                    scale: 2
                });
            } else {
                alert('Please create a plot first before exporting.');
            }
        }

        function clearManhattanPlot() {
            document.getElementById('manhattanPlotDiv').innerHTML =
                '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666;">Manhattan plot cleared. Click "Plot from Cleaned Data" to display data.</div>';
            document.getElementById('manhattanStats').textContent = 'Manhattan plot cleared.';
            hideManhattanProgress();

            if (manhattanWorker) {
                manhattanWorker.terminate();
                manhattanWorker = null;
            }
            manhattanCurrentData = null;
        }
    </script>
    <script src="public/plotly.min.js"></script>
</body>
</html>